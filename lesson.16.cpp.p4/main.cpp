#include <iostream>

#include "../lesson.14.cpp/Fabric.h"

Fabric::Ptr IoC = std::make_shared<Fabric>();

#include "../lesson.03.cpp/UObject.h"
#include "../lesson.03.cpp/IExecuteable.h"
#include "./Testing/TocableAdapter.h"

namespace Execute {
	class SetProperty : public IExecuteable {
	private:
		UObject::Ptr m_pObj;
		std::string m_strProperty;
		std::any m_anyValue;

	public:
		SetProperty(UObject::Ptr pObj, std::string strProperty, std::any anyValue) : m_pObj(std::move(pObj)), m_strProperty(std::move(strProperty)), m_anyValue(std::move(anyValue)) {}

		virtual void Execute() override {
			m_pObj->SetProperty(m_strProperty, m_anyValue);
		}
	};

	class Action : public IExecuteable {
	public:
		typedef std::function<void(UObject::Ptr&)> Lambda;
	private:
		UObject::Ptr m_pObj;
		Lambda m_lambda;

	public:
		Action(UObject::Ptr pObj, Lambda lambda) : m_pObj(std::move(pObj)), m_lambda(std::move(lambda)) {}

		virtual void Execute() override {
			m_lambda(m_pObj);
		}
	};
}

void Dump(const std::string& strTitle, const std::vector<std::string>& chapters) {
	std::cout << "Finish called for " << strTitle << std::endl;
	for (size_t idx = 0; idx < chapters.size(); ++idx)
		std::cout << "\t" << idx << ": " << chapters[idx] << std::endl;
}

int main()
{
	Fabric::Register(
		IoC,
		"Library.Register.Tocable:Title.Get",
		[](Fabric::Args args) {
			UObject::Ptr pObj = Fabric::GetRequiredArg<UObject::Ptr>(args, 0, "UObject expected");
			std::string strTitle = std::any_cast<std::string>(pObj->GetProperty("title"));
			return std::any(strTitle);
		}
	);
	Fabric::Register(
		IoC,
		"Library.Register.Tocable:Title.Set",
		[](Fabric::Args args) {
			UObject::Ptr pObj = Fabric::GetRequiredArg<UObject::Ptr>(args, 0, "UObject expected");
			std::string strTitle = Fabric::GetRequiredArg<std::string>(args, 1, "Title expected");
			IExecuteable::Ptr pSetProperty = std::make_shared<::Execute::SetProperty>(pObj, "title", strTitle);
			return std::any(pSetProperty);
		}
	);
	Fabric::Register(
		IoC,
		"Library.Register.Tocable:Chapters.Get",
		[](Fabric::Args args) {
			UObject::Ptr pObj = Fabric::GetRequiredArg<UObject::Ptr>(args, 0, "UObject expected");
			std::vector<std::string> chapters = std::any_cast<std::vector<std::string>>(pObj->GetProperty("chapters"));
			return std::any(chapters);
		}
	);
	Fabric::Register(
		IoC,
		"Library.Register.Tocable:Chapters.Set",
		[](Fabric::Args args) {
			UObject::Ptr pObj = Fabric::GetRequiredArg<UObject::Ptr>(args, 0, "UObject expected");
			std::vector<std::string> chapters = Fabric::GetRequiredArg<std::vector<std::string>>(args, 1, "Chapters expected");
			IExecuteable::Ptr pSetProperty = std::make_shared<::Execute::SetProperty>(pObj, "chapters", chapters);
			return std::any(pSetProperty);
		}
	);
	Fabric::Register(
		IoC,
		"Library.Register.Tocable:Finish",
		[](Fabric::Args args) {
			UObject::Ptr pObj = Fabric::GetRequiredArg<UObject::Ptr>(args, 0, "UObject expected");
			::Execute::Action::Lambda lambda = [](UObject::Ptr& pObj) {
				std::string strTitle = std::any_cast<std::string>(pObj->GetProperty("title"));
				std::vector<std::string> chapters = std::any_cast<std::vector<std::string>>(pObj->GetProperty("chapters"));
				Dump(strTitle, chapters);
			};
			IExecuteable::Ptr pFinish = std::make_shared<::Execute::Action>(pObj, lambda);
			return std::any(pFinish);
		}
	);

	UObject::Ptr pObj = std::make_shared<UObject>();
	::Library::Register::Tocable::Ptr pTocable = std::make_shared<::Autogenerated::Library::Register::TocableAdapter>(pObj);
	pTocable->SetTitle("Random Title");
	pTocable->SetChapters({ "Prologue", "Part 1", "Part 2", "Epilogue" });
	pTocable->Finish();
	std::cout << std::endl;
	Dump(pTocable->GetTitle(), pTocable->GetChapters());
}