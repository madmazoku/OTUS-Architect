#include "Parser.h"

#include <regex>
#include <string>
#include <deque>

const std::regex g_reNamespace("^\\s*namespace\\s([a-zA-Z0-9_]+)\\s\\{$");
const std::regex g_reClass("^\\s*class\\s([a-zA-Z0-9_]+)");
const std::regex g_reGetter("^\\s*virtual\\s(.+)\\sGet([a-zA-Z0-9_]+)\\(\\)(\\sconst)?\\s=\\s0;$");
const std::regex g_reSetter("^\\s*virtual\\svoid\\sSet([a-zA-Z0-9_]+)\\((.+)\\)\\s=\\s0;$");
const std::regex g_reAction("^\\s*virtual\\svoid\\s([a-zA-Z0-9_]+)\\(\\)\\s=\\s0;$");
const std::regex g_reClose("^\\s*\\};?$");

const std::string g_Ident = "    ";

std::string Ident(size_t size) {
	std::string strIdent;
	while (--size > 0)
		strIdent += g_Ident;
	return strIdent;
}

std::string Concat(std::deque<std::string> parts, const std::string& div) {
	std::string str;
	for (const std::string& p : parts) {
		if (!str.empty())
			str += div;
		str += p;
	}
	return str;
}

void Translate(std::istream& inputStream, std::ostream& outputStream) {
	outputStream << "namespace Autogenerated {\n";
	std::deque<std::string> deqNamespaces;
	std::string strClass;
	std::string strNamespaces;
	std::string strIdent;
	while (!inputStream.eof()) {
		std::string line;
		std::getline(inputStream, line);
		std::smatch m;
		if (std::regex_match(line, m, g_reNamespace)) {
			if (!strClass.empty())
				throw std::runtime_error(std::string("namespace '") + m[1].str() + std::string("' inside of class '") + strClass + std::string("'"));
			deqNamespaces.emplace_back(m[1].str());
			outputStream << Ident(deqNamespaces.size() + 1) << "namespace " << m[1].str() << " {\n";
			continue;
		}
		if (std::regex_match(line, m, g_reClass)) {
			if (deqNamespaces.empty())
				throw std::runtime_error(std::string("at least one namespace required before class '") + m[1].str() + std::string("'"));
			strClass = m[1].str();
			for (const std::string& ns : deqNamespaces) {
				if (!strNamespaces.empty())
					strNamespaces += ".";
				strNamespaces += ns;
			}
			strIdent = Ident(deqNamespaces.size() + 2);
			outputStream << strIdent << "class " << strClass << "Adapter : public ::" << Concat(deqNamespaces, "::") << "::" << strClass << "\n";
			outputStream << strIdent << "{\n";
			outputStream << strIdent << "private:\n";
			outputStream << strIdent << g_Ident << "UObject::Ptr m_pUObject;\n";
			outputStream << strIdent << "public:\n";
			outputStream << strIdent << g_Ident << strClass << "Adapter(UObject::Ptr pUObject) : m_pUObject(std::move(pUObject)) {}\n";
			strNamespaces = Concat(deqNamespaces, ".");
			strIdent += g_Ident;
			continue;
		}
		if (std::regex_match(line, m, g_reGetter)) {
			outputStream << strIdent << "virtual " << m[1].str() << " Get" << m[2].str() << "()" << m[3].str() << " override {\n";
			outputStream << strIdent << g_Ident << "return IoC->Resolve<" << m[1].str() << ">(\"" << strNamespaces << "." << strClass << ":" << m[2].str() << ".Get\", {m_pUObject});\n";
			outputStream << strIdent << "}\n";
			continue;
		}
		if (std::regex_match(line, m, g_reSetter)) {
			outputStream << strIdent << "void Set" << m[1].str() << "(" << m[2].str() << " value) override {\n";
			outputStream << strIdent << g_Ident << "IoC->Resolve<IExecuteable::Ptr>(\"" << strNamespaces << "." << strClass << ":" << m[1].str() << ".Set\", {m_pUObject, value})->Execute();\n";
			outputStream << strIdent << "}\n";
			continue;
		}
		if (std::regex_match(line, m, g_reAction)) {
			outputStream << strIdent << "void " << m[1].str() << "() override {\n";
			outputStream << strIdent << g_Ident << "IoC->Resolve<IExecuteable::Ptr>(\"" << strNamespaces << "." << strClass << ":" << m[1].str() << "\", {m_pUObject})->Execute(); \n";
			outputStream << strIdent << "}\n";
			continue;
		}
		if (std::regex_match(line, m, g_reClose)) {
			if (!strClass.empty()) {
				outputStream << Ident(deqNamespaces.size() + 2) << "};\n";
				strClass.clear();
				strNamespaces.clear();
				strIdent.clear();
			}
			else if (deqNamespaces.empty())
				throw std::runtime_error("too much closes");
			else {
				outputStream << Ident(deqNamespaces.size() + 1) << "}\n";
				deqNamespaces.pop_back();
			}
			continue;
		}
	}
	outputStream << "}\n";
}